
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>Chapter 5 Â· HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../chapter6/" />
    
    
    <link rel="prev" href="../chapter4/" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../conventions/">
            
                <a href="../conventions/">
            
                    
                    Conventions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../chapter1/">
            
                <a href="../chapter1/">
            
                    
                    Chapter 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../chapter2/">
            
                <a href="../chapter2/">
            
                    
                    Chapter 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../chapter3/">
            
                <a href="../chapter3/">
            
                    
                    Chapter 3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../chapter4/">
            
                <a href="../chapter4/">
            
                    
                    Chapter 4
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.7" data-path="./">
            
                <a href="./">
            
                    
                    Chapter 5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../chapter6/">
            
                <a href="../chapter6/">
            
                    
                    Chapter 6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../chapter7/">
            
                <a href="../chapter7/">
            
                    
                    Chapter 7
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../chapter8/">
            
                <a href="../chapter8/">
            
                    
                    Chapter 8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../chapter9/">
            
                <a href="../chapter9/">
            
                    
                    Chapter 9
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="../chapter10/">
            
                <a href="../chapter10/">
            
                    
                    Chapter 10
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="../chapter11/">
            
                <a href="../chapter11/">
            
                    
                    Chapter 11
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="../chapter12/">
            
                <a href="../chapter12/">
            
                    
                    Chapter 12
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Chapter 5</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="event-listeners-and-class-component-state">Event Listeners and Class Component State</h1>
<ul>
<li><a href="#event-listeners-and-class-component-state">Event Listeners and Class Component State</a><ul>
<li><a href="#reviewing-javascript-events">Reviewing JavaScript Events</a></li>
<li><a href="#react-synthetic-events">React Synthetic Events</a></li>
<li><a href="#problems-with-this">Problems with <code>this</code></a><ul>
<li><a href="#public-class-fields">Public Class Fields</a></li>
<li><a href="#arrow-function-listeners">Arrow Function Listeners</a></li>
<li><a href="#binding-this">Binding <code>this</code></a></li>
</ul>
</li>
<li><a href="#understanding-thisstate">Understanding <em>this.state</em></a><ul>
<li><a href="#updating-state">Updating State</a></li>
<li><a href="#using-setstate">Using <strong>setState()</strong></a></li>
<li><a href="#setstate-callback"><strong>setState()</strong> Callback</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="reviewing-javascript-events">Reviewing JavaScript Events</h2>
<p>Part of the document object model (DOM) in web browsers is support for HTML events. When an agent is interacting with a document, different common events occur. This includes the more common <code>click</code> events, but also extends through other things like page loading and even HTML5 support for controllers or even VR platforms. All of these different interfaces and actions all generate <em>events</em>.</p>
<p>In HTML, an event occurs on an element and moves through what is known as <em>event bubbling</em> as it moves up from itself to its parent and continuing to the global <strong>document</strong> object. Events start where they occur, like with clicking, and move through the document unless stopped or they run out of parent elements.</p>
<p>To know if an event has occurred or not, JavaScript in web browser has support for <em>event listeners</em>. These are callback functions setup to listen for specific events and then respond in some way. All advanced interactions with documents like moving elements around on the page or even loading new content dynamically works through event listeners.</p>
<p>Because events work on the element-level, every one has a large set of built-in attributes for listening for particular events. These all start with the word <code>on</code> and are followed by the name of the event. For example, a function set as the value to the attribute <code>onClick</code> would be called if a <code>click</code> event happened on that event.</p>
<p>For example, to react to a particular <code>&lt;p&gt;</code> element being clicked, the code might look like the following:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">'() =&gt; { console.log("Clicked!") }'</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</code></pre>
<p>In the above case, the arrow function would call a function inside of it, <strong>console.log()</strong>. It would <em>only</em> be called if the particular event, <code>click</code>, happened. Otherwise, it would be ignored.</p>
<h2 id="react-synthetic-events">React Synthetic Events</h2>
<p>React creates <em>synthetic events</em> that act like real ones, but are filtered through its own set. These condense some of the events that can happen in web browsers, and also allows React to track everything and only update the page when the event would affect how either its own or another component's rendered elements would be shown.</p>
<p>These include, for example, for mouse events, events like the following:</p>
<ul>
<li><p>onClick</p>
</li>
<li><p>onContextMenu</p>
</li>
<li><p>onDoubleClick</p>
</li>
<li><p>onMouseEnter</p>
</li>
<li><p>onMouseLeave</p>
</li>
<li><p>onMouseMove</p>
</li>
<li><p>onMouseOut</p>
</li>
<li><p>onMouseOver</p>
</li>
<li><p>onMouseUp</p>
</li>
</ul>
<h2 id="problems-with-this">Problems with <code>this</code></h2>
<p>When event listeners are used within classes in JavaScript, a unique issue arises. Because functions within a class are usually called within the scope of the class, the use of its <code>this</code> refers to the class itself. However, event listeners do not use this. Any functions called as part of an event listener is executed outside of its defined scope. This creates a problem.</p>
<p>Consider the following code:</p>
<p><strong>index.js:</strong></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">example</span> = <span class="hljs-string">"Hi!"</span>;
  }

  <span class="hljs-title function_">clickListener</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">example</span>);
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.clickListener}</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>While React will have no problem with the value of a function being used as a callback function for the synthetic event of <code>onClick</code> in React, it will have a problem when called. The property <em>this.example</em> will not exist in the calling context! It only exists within the scope of the class and not for the event listener itself.</p>
<p>There are three solutions to this issue:</p>
<h3 id="public-class-fields">Public Class Fields</h3>
<p>Using a public class field with the value of an arrow function allows a class function to reference the <code>this</code> of a class (where it is defined) even if it is run in a different context.</p>
<p>As this is the exact issue with using event listeners, such a solution makes it very popular with React developers.</p>
<p>Consider the following code that now uses a public class field:</p>
<p><strong>index.js:</strong></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">example</span> = <span class="hljs-string">"Hi!"</span>;
  }

  clickListener = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">example</span>);
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.clickListener}</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>However, while it seems ideal, it also comes with two small problems. First, any classes that extend a class that uses public class fields get a property that has the value of a function, <em>not</em> a function itself. This is a small but often important difference for classes that inherit from other classes within a project.</p>
<p>The second is that it is an experimental feature. React supports it because Babel does, but not all JavaScript environments fully support it yet. Once it becomes part of the specification, adoption will improve and it will slowly show up in other environments like web browsers without needing help from tools like Babel to "translate" the code.</p>
<h3 id="arrow-function-listeners">Arrow Function Listeners</h3>
<p>Event listeners in JavaScript in web browsers take the value of a function and run said function when an event happens. The key term "value" opens the door to using arrow functions in a new way: as event listeners that call other functions!</p>
<p>Another common way to avoid the issue with event listeners being called in a different context than a class is to use an arrow function as the "listening" function and then have it call something else.</p>
<p>Arrow functions take their <code>this</code> from where they are defined. As long as the arrow function is defined within the class, its own <code>this</code> will be the class itself.</p>
<p>Consider the following code:</p>
<p><strong>index.js:</strong></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">example</span> = <span class="hljs-string">"Hi!"</span>;
  }

  <span class="hljs-title function_">clickListener</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">example</span>);
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span>
          () =&gt;</span> { this.clickListener() }
          }&gt;Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>In the above code, the arrow function is used as the event listener function. It then calls, using the <code>this</code> of the class, another function within the class.</p>
<p>While this technique is also frequently used in React code, it also comes with a problem to remember: each copy of the element with those exact attributes creates an extra function for the sole purpose of calling another function.</p>
<p>While it can be used in small amounts, it not recommended to generate large lists or create many components using the same functionality. Creating lots of small functions that simply call other functions is potentially a waste of application memory.</p>
<h3 id="binding-this">Binding <code>this</code></h3>
<p>Early developers of React used a technique that is still fairly popular: binding <code>this</code>.</p>
<p>The function <strong>bind()</strong> can be used on any function to change its internal <code>this</code>. It then returns a new function based on the old one, but changed.</p>
<p>In the case of binding <code>this</code> in React, a function within a class is "re-binded" inside a <strong>constructor()</strong>. Before it is used, then, its own <code>this</code> is the same as that of the class in which it is defined.</p>
<p>For event listeners, this means that the <code>this</code> of the function will always be the class, even when the code is run in a different context.</p>
<p>Consider the following code:</p>
<p><strong>index.js:</strong></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">example</span> = <span class="hljs-string">"Hi!"</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">clickListener</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">clickListener</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);

  }

  <span class="hljs-title function_">clickListener</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">example</span>);
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.clickListener}</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>While popular in some circles, the binding of <code>this</code> also creates its own problem: the original function's <code>this</code> is still the same. Anything class that inherits the function and wants to use it as an event listener will have to re-bind it again within its own constructor. This adds, with multiple events, multiple lines of code to re-bind each one's <code>this</code> to the class.</p>
<h2 id="understanding-thisstate">Understanding <em>this.state</em></h2>
<p><em>Components take care of themselves.</em></p>
<p>While each component should only be concerned with its own elements, what happens if it needs to keep track of data somehow? In those cases, each component can have its own <em>state</em>.</p>
<p>State can be added to a component through creating a property <em>this.state</em> inside of a class component's <strong>constructor()</strong> (or as a public class field). Because it is part of the class, it can be accessed anywhere inside of it.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">example</span> = <span class="hljs-string">"Hi!"</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {
      <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>;
    }

  }

  clickListener = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span>++;
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.clickListener}</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        {this.state.counter}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>While the above code my seem like the answer, it is not. The reason why has to do with React and its use of <strong>render()</strong>. In the above code, the value of <em>this.state.counter</em> would be updated, but its new value would not be shown. <strong>render()</strong> would need to be called again!</p>
<h3 id="updating-state">Updating State</h3>
<p>To help with this common task, the class <strong>React.Component</strong> has a special function designed for only updating state: <strong>setState()</strong>.</p>
<p>Inherited from <strong>React.Component</strong>, <strong>setState()</strong> seemingly only does one thing: updates <em>this.state</em>. However, it also does another thing internally: it also calls <strong>render()</strong>! Any use of <strong>setState()</strong> will update the internal <em>this.state</em> and have any updated values become part of the next call to <strong>render()</strong>. (This also, like all things React, allows it to collect potential changes and decide when to update the DOM to be most efficient.)</p>
<h3 id="using-setstate">Using <strong>setState()</strong></h3>
<p>Since React makes its own decision to update the <em>this.state</em> as part of additional <strong>render()</strong> calls, this create a new rule: do not change the values of <em>this.state</em> outside of <strong>setState()</strong>!</p>
<p>The reason for this rule is simple. If React has not yet updated what a class component is rendering, any changes to <em>this.state</em> outside of using <strong>setState()</strong> would be overwritten since the last render. In other words, changes would be missed between render cycles!</p>
<p>To avoid this, it is strongly recommended to edit values only inside of a call to <strong>setState()</strong> or, if needed, to make a copy of a particular property to protect the overall object from accidentally being changed before the next call to <strong>render()</strong>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">example</span> = <span class="hljs-string">"Hi!"</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {
      <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>;
    }

  }

  clickListener = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(
      <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span>++
        }
      }
    );
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.clickListener}</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        {this.state.counter}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>In the above example, any call to the public class field <em>clickListener</em> would also call <strong>this.setState()</strong>. In the new code, the function <strong>this.setState()</strong> is being passed an arrow function whose job it is to update a property of <em>this.state</em> through returning an object with an updated property.</p>
<p>Using a function is one way to update <em>this.state</em>. <strong>setState()</strong> also accepts objects.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">example</span> = <span class="hljs-string">"Hi!"</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {
      <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>;
    }

  }

  clickListener = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({<span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span>++});
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.clickListener}</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        {this.state.counter}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>In the above example, the call to <strong>setState()</strong> is given an object with the updated property and its new value. Internally, <strong>setState()</strong> would only update that single property and leave any others unchanged.</p>
<p>Depending on the need, either use of <strong>setState()</strong> could be a solution. For more complicated calculations or to change multiple properties, an arrow function could be used. For updating a single property, passing a single object might make more sense.</p>
<h3 id="setstate-callback"><strong>setState()</strong> Callback</h3>
<p><strong>setState()</strong> also accepts an optional callback function as a second argument. This can be useful in those situations where the data of a state change is needed right after it happens.</p>
<p>Consider the limited following code example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Day</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {
      <span class="hljs-attr">day</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">events</span>: []
    }

  }

  setDay = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(
      {<span class="hljs-attr">day</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">day</span> + <span class="hljs-number">1</span>},
      <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadEvents</span>();
      });
  }

  <span class="hljs-title function_">loadEvents</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Load events based on the current day</span>
    <span class="hljs-comment">// Pull the day from this.state.day</span>
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.clickListener}</span>&gt;</span>Day {this.state.day}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        {
          this.events.forEach((entry) =&gt; {
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{entry}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
          })
        }
        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>In the above example, the next day is loaded based on what the current value of <em>this.state.day</em> is, calling the internal function <strong>this.loadEvents()</strong> as part of a callback to <strong>setState()</strong>. Whenever the user changed the day, all of the current events would be reloaded.</p>
<p>However, while code could work like this, it is <em>not recommended</em>. The callback function option is provided to fine-tune operations and other, more general functionality should be used in this same instance to make sure components are updated <em>before</em> potentially loading on more data and processing it somehow. This example is provided to show it could be done, not that it should.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../chapter4/" class="navigation navigation-prev " aria-label="Previous page: Chapter 4">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../chapter6/" class="navigation navigation-next " aria-label="Next page: Chapter 6">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Chapter 5","level":"1.7","depth":1,"next":{"title":"Chapter 6","level":"1.8","depth":1,"path":"chapter6/index.md","ref":"chapter6/index.md","articles":[]},"previous":{"title":"Chapter 4","level":"1.6","depth":1,"path":"chapter4/index.md","ref":"chapter4/index.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"root":"./chapters","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*"},"file":{"path":"chapter5/index.md","mtime":"2025-06-16T06:04:49.075Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-06-16T06:54:47.069Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

